<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <title>Dodaj produkt</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>

<body>

    <img src="{{ url_for('static', filename='images/header.jpg') }}" alt="Opis obrazu" class="site-header">


    <h1>Dodaj produkt do zamówienia</h1>
    <form action="{{ url_for('dodaj_produkt') }}" method="post">
        <div class="product-table-wrapper">
        <table class="product-table">
            <thead>
                <tr>
                    <th>Producent</th>
                    <th>Materiał</th>
                    <th>Typ</th>
                    <th>Długość [cm]</th>
                    <th>Szerokość [cm]</th>
                    <th>Grubość [cm]</th>
                    <th>Rabat [%]</th>
                    <th>Obróbka</th>
                    <th>Ilość</th>
                </tr>
            </thead>
            <tbody id="productTable">
                {% for produkt in lista_produktow %}
                <tr data-row-id="{{ loop.index0 }}">
                    <td>
                        <select name="producent_{{ loop.index0 }}" required onchange="updateMaterials(this)">
                            <option value="Forma system" {% if produkt.producent.nazwa == "Forma system" %}selected{% endif %}>Forma system</option>
                            <option value="Imperial" {% if produkt.producent.nazwa == "Imperial" %}selected{% endif %}>Imperial</option>
                            <option value="Olgran" {% if produkt.producent.nazwa == "Olgran" %}selected{% endif %}>Olgran</option>
                            <option value="O rety parapety" {% if produkt.producent.nazwa == "O rety parapety" %}selected{% endif %}>O rety parapety</option>
                            <option value="Stolarz" {% if produkt.producent.nazwa == "Stolarz" %}selected{% endif %}>Stolarz</option>
                        </select>
                    </td>
                    <td>
                        <input type="text" id="material_{{ loop.index0 }}" name="material_{{ loop.index0 }}" list="materialsList{{ loop.index0 }}" oninput="filterMaterials(this, 'materialsList{{ loop.index0 }}')" required value="{{ produkt.material }}">
                        <datalist id="materialsList{{ loop.index0 }}"></datalist>
                    </td>
                    <td>
                        <select name="typ_{{ loop.index0 }}" required>
                            <option value="{{ produkt.typ }}" selected>{{ produkt.typ }}</option>
                        </select>
                    </td>
                    <td><input type="text" name="dlugosc_{{ loop.index0 }}" value="{{ produkt.dlugosc }}" required></td>
                    <td><input type="text" name="szerokosc_{{ loop.index0 }}" value="{{ produkt.szerokosc }}" required></td>
                    <td>
                        <select name="grubosc_{{ loop.index0 }}" required>
                            <option value="{{ produkt.grubosc }}" selected>{{ produkt.grubosc }}</option>
                        </select>
                    </td>
                    <td><input type="number" name="rabat_{{ loop.index0 }}" value="{{ produkt.rabat if produkt.rabat is defined else 0 }}" min="0" max="100"></td>
                    <td><button type="button" class="addObrobka" data-row-id="{{ loop.index0 }}">Dodaj obróbkę</button></td>
                    <input type="hidden" name="obrobki_{{ loop.index0 }}" value="{{ produkt.obrobki | join(', ') }}">
                    <td><input type="text" name="ilosc_{{ loop.index0 }}" value="{{ produkt.ilosc }}" required></td>
                    <td><button type="button" class="removeRow">Usuń</button></td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
        </div>
        <br>
        <div class="form-actions">
          <button type="button" id="addRow" class="btn btn--large">Dodaj produkt</button>

          <h1 id="customObrobkiHeader" class="{% if not custom_obrobki %}hidden{% endif %}">Dodatkowe obróbki</h1>
          <table id="customObrobkiTable" class="{% if not custom_obrobki %}hidden{% endif %}">
              <thead>
                  <tr>
                      <th>Nazwa obróbki</th>
                      <th>Cena [zł]</th>
                      <th>Usuń</th>
                  </tr>
              </thead>
              <tbody>
                  {% for obrobka in custom_obrobki %}
                  <tr>
                      <td><input type="text" name="custom_obrobka_nazwa_{{ loop.index0 }}" value="{{ obrobka.nazwa }}" required></td>
                      <td><input type="number" name="custom_obrobka_cena_{{ loop.index0 }}" value="{{ obrobka.cena }}" step="0.01" required></td>
                      <td><button type="button" onclick="this.closest('tr').remove()">Usuń</button></td>
                  </tr>
                  {% endfor %}
              </tbody>
          </table>

          <button type="button" class="btn btn--large btn-ghost" onclick="pokazTabeleObrobek()">Dodaj dodatkową obróbkę</button>

          <button type="submit" class="btn btn--large btn--primary">Zatwierdź zamówienie</button>
        </div>
    </form>    

    <div id="obrobkaModal">
        <div class="modal-close" id="closeObrobkaModal">&times;</div>
        <h2>Dodaj obróbkę</h2>
        <div id="obrobkaList"></div>
        <button id="zapiszObrobki" class="modal-save-button">Zapisz</button>
    </div>

    <script>

        const materials = {
            "O rety parapety": [
                "Ariston", "Botticino", "Baltic Grey", "Beige Marfil", "Bianco Ghiaccio", "Bianco Neve", "Breccia Aurora", "Calacatta", "Ceniza Pearl", "Madra Perla", "Misty White", "Nero Portoro",
                "Perlato Appia", "Polare", "Rosa Del Garda", "Royal Beige"

            ],
            "Olgran": [
                "Super White", "Balmoral", "Bianco", "Strzeblów", "Strzegom", "Strzelin", "Bohus Grey", "Red", "Brąz Królewski", "Classic Brown", "Dark Grey", "Impala Marikana Dark", "Kashmir",
                "Colonial", "Valley", "Winter", "Coffee Brown", "Magma Gold", "Titanium Gold", "New Dark Grey", "Oscuro", "Titanium", "Forest", "Silver Paradiso", "Nero Assoluto", "Premium Black",
                "Nero Assoluto Satyna", "Premium Black Satyna", "Saida", "Santorini", "Spring Falls", "Star Gate", "Steel Grey Lappato", "Shivakashi", "Honey Dew", "Tan Brown", "Tołkowski", "Vanga",
                "Wiscount White", "Bianco Carrara", "Brecia Sarda", "Crema Marfil", "New Marfil", "Ambiente Light", "Angela Premium (CPW)", "Brilliant Black", "Calacatta Olympos", "Calacatta Silva",
                "Crystal Absolute White", "Crystal Anthracite", "Crystal Polar White", "Gobi Grey", "Noble Carrara", "Noble Quarzite", "Noble Concrete Grey", "Stardust (Desert Silver)", "Vera Gold",
                "Adamantium", "Artemis", "Elysium", "Polaris Gold", "Ocean", "Taj Mahal", "Black Forest", "Cheyenne", "Thunder Black", "Sapphire Blue", "Crystal Diamond", "Statuario Bella", "Nove",
                "Taj Mahal (konglomerat)"
            ],
            "Imperial": [
                "Nero Antico", "Nero Satyna", "Nero Via Lactea", "Star Galaxy", "Steel Grey", "Altamonte", "Glencoe", "Bronze Coast", "Atlas Gold", "Atlas White", "Pico", "Atlas Gold Mat", "Cappucino",
                "Golden Dawn", "Nestos", "Maple Gaze", "Galactic Halo", "Venus Glow", "Imagine Grey", "Noble Areti Bianco", "Noble Supreme White", "Noble Pro Frost", "Taj Mahal (konglomerat kwarcowy)",
                "Taj Mahal Mat (konglomerat kwarcowy)", "Technistone Taj Mahal (konglomerat kwarcowy)", "Technistone Taj Mahal Mat (konglomerat kwarcowy)", "Technistone Mistral White", "Taj Mahal", "Negresco"
            ],
            "Stolarz": [
                "Dąb"
            ],
            "Forma system": [
                "Elegance Eco Nev", "Gobi Grey", "Crystal Royal", "Gobi Black", "Taurus Black", "Crystal Diamond", "Starlight Black", "Crystal Absolute White", "Crystal Polar White",
                "Noble Carrara", "Noble Concrete Grey", "Noble Ivory White", "Noble Pro Frost", "Noble Quartzite", "Nobe Athos Brown", "Noble Linea", "Noble Areti Bianco", "Mistral White", "Noble Imperial Grey",
                "Noble Supreme White", "Ambiente Light", "Crystal Calacatta Silva", "Glencoe", "Calacatta Olympos", "Mystery White", "Blanco Maple", "Coral Clay", "Negro Tebas", "Linen Cream",
                "Motion Grey", "Desert Silver", "Lagoon", "Snowy Ibiza", "Persian White", "Siberian Frost", "Blanco Zeus", "Eternal Statuario", "White Arabesque", "Eternal Calacatta Gold",
                "Ethereal Glow", "Charcoal Soapstone", "Et. Noir", "Rivere Rose", "Blanc Eysee", "Versailles Invory", "Parisien Blue", "Negro Tebas Suede", "Desert Silver Suede",
                "Coral Clay Suede", "Lime Delight Suede", "Charcoal Soapstone Suede", "Brasil", "White Ocean", "Dolomite Grey", "Emerald Dream", "Marmi Lava", "Madrea Green",
                "India Pearl", "Arctic Storm", "Alpine Blue", "Eter", "Danae", "Kairos", "Kira", "Sabbia", "Trilium", "Grigio", "Grafite", "Ava", "Marmorio", "Nebbia", "Nebu", "Sandik",
                "Kelya", "Kreta", "Sirius", "Laos", "Soke", "Aura", "Entzo", "Laurent", "Rem", "Arga", "Albarium", "Bergen", "Helena", "Taga", "Zenith", "State", "Nerok",
                "Novam", "Zephyr", "Linen Cream Suede"
            ]
        };

        const forma_technistone = [
            "Elegance Eco Nev", "Gobi Grey", "Crystal Royal", "Gobi Black", "Taurus Black", "Crystal Diamond", "Starlight Black", "Crystal Absolute White", "Crystal Polar White",
            "Noble Carrara", "Noble Concrete Grey", "Noble Ivory White", "Noble Pro Frost", "Noble Quartzite", "Nobe Athos Brown", "Noble Linea", "Noble Areti Bianco", "Noble Imperial Grey",
            "Noble Supreme White", "Ambiente Light", "Crystal Calacatta Silva", "Glencoe", "Calacatta Olympos", "Mystery White", "Blanco Maple", "Coral Clay", "Negro Tebas", "Linen Cream Suede", "Linen Cream",
            "Motion Grey", "Desert Silver", "Lagoon", "Snowy Ibiza", "Persian White", "Siberian Frost", "Blanco Zeus", "Eternal Statuario", "White Arabesque", "Eternal Calacatta Gold",
            "Ethereal Glow", "Charcoal Soapstone", "Et. Noir", "Rivere Rose", "Blanc Eysee", "Versailles Invory", "Parisien Blue", "Negro Tebas Suede", "Desert Silver Suede",
            "Coral Clay Suede", "Lime Delight Suede", "Charcoal Soapstone Suede", "Brasil", "White Ocean", "Dolomite Grey", "Emerald Dream", "Marmi Lava", "Madrea Green",
            "India Pearl", "Arctic Storm", "Alpine Blue", "Mistral White"
        ];

        const forma_dekton = [
            "Eter", "Danae", "Kairos", "Kira", "Sabbia", "Trilium", "Grigio", "Grafite", "Ava", "Marmorio", "Nebbia", "Nebu", "Sandik",
                "Kelya", "Kreta", "Sirius", "Laos", "Soke", "Aura", "Entzo", "Laurent", "Rem", "Arga", "Albarium", "Bergen", "Helena", "Taga", "Zenith", "State", "Nerok",
                "Novam", "Zephyr"
        ];

        const thicknesses = {};

        let customObrobkaIndex = {{ custom_obrobki|length if custom_obrobki else 0 }};
        // Unique incrementing id for rows to avoid re-using ids after removals
        let nextRowId = document.querySelectorAll('#productTable tr').length;

        function dodajWierszCustomObrobki() {
            const table = document.getElementById("customObrobkiTable").querySelector("tbody");
            const row = document.createElement("tr");

            row.innerHTML = `
                <td><input type="text" name="custom_obrobka_nazwa_${customObrobkaIndex}" required></td>
                <td><input type="number" name="custom_obrobka_cena_${customObrobkaIndex}" step="0.01" required></td>
                <td><button type="button" onclick="this.closest('tr').remove()">Usuń</button></td>
            `;

            table.appendChild(row);
            customObrobkaIndex++;
            // Ensure the custom obróbki section is visible after adding
            updateCustomObrobkiVisibility();
        }

        // Helpers to show/hide tables when empty
        function updateProductTableVisibility() {
            const tbody = document.getElementById('productTable');
            const table = tbody ? tbody.closest('table') : null;
            if (!tbody || tbody.querySelectorAll('tr').length === 0) {
                if (table) table.classList.add('hidden');
            } else {
                if (table) table.classList.remove('hidden');
            }
        }

        function updateCustomObrobkiVisibility() {
            const table = document.getElementById('customObrobkiTable');
            const header = document.getElementById('customObrobkiHeader');
            const tbody = table ? table.querySelector('tbody') : null;
            if (!tbody || tbody.querySelectorAll('tr').length === 0) {
                if (table) table.classList.add('hidden');
                if (header) header.classList.add('hidden');
            } else {
                if (table) table.classList.remove('hidden');
                if (header) header.classList.remove('hidden');
            }
        }

        for (const company in materials) {
            materials[company].forEach(material => {
                let thickness;

                if (company === "O rety parapety") {
                    thickness = [2.0, 3.0];
                } else if (company === "Olgran" || company === "Imperial") {
                    thickness = [2.0, 3.0];
                } else if (company === "Stolarz") {
                    thickness = [3.0, 4.0, 5.0, 6.0];
                } else if (company === "Forma system") {
                    thickness = [2.0, 1.2]
                }

                if (!thicknesses[material]) {
                    thicknesses[material] = {};
                }

                thicknesses[material][company] = thickness;
            });
        }

        function formatThickness(thickness) {
            return Number.isInteger(thickness) ? thickness.toString() : thickness.toFixed(1);
        }

        function formatThickness(thickness) {
            const num = parseFloat(thickness);
            if (Number.isNaN(num)) return thickness;
            return Number.isInteger(num) ? num.toString() : num.toFixed(1);
        }

        function updateThickness(row) {
            const producent = row.querySelector("select[name^='producent']").value;
            const material = row.querySelector("input[name^='material']").value;
            const thicknessSelect = row.querySelector("select[name^='grubosc']");

            let currentValue = formatThickness(thicknessSelect.value);

            thicknessSelect.innerHTML = "";

            const possibleThicknesses = [];

            if (thicknesses[material] && thicknesses[material][producent]) {
                thicknesses[material][producent].forEach(thickness => {
                    const formatted = formatThickness(thickness);
                    possibleThicknesses.push(formatted);
                    const option = document.createElement("option");
                    option.value = formatted;
                    option.textContent = formatted;
                    thicknessSelect.appendChild(option);
                });
            }

            // Teraz sprawdź: jeśli obecna wartość istnieje w możliwych opcjach → ustaw ją
            if (possibleThicknesses.includes(currentValue)) {
                thicknessSelect.value = currentValue;
            } else if (possibleThicknesses.length > 0) {
                // jeśli nie — wybierz pierwszą dostępną
                thicknessSelect.value = possibleThicknesses[0];
            }
        }


        // ZASTĄP istniejący listener "input" poniższym kodem
        document.addEventListener("input", function (event) {
            // Obsługa zmian w polu "material"
            if (event.target.name && event.target.name.startsWith("material")) {
                const row = event.target.closest("tr");

                // 1) Aktualizuj grubość (zachowujemy Twoją dotychczasową logikę)
                updateThickness(row);

                // 2) Jeśli pole materiału zostało wyczyszczone, odbuduj datalistę dla bieżącego producenta
                const materialValue = event.target.value.trim();
                const producentSelect = row.querySelector("select[name^='producent']");
                const materialInput = row.querySelector("input[name^='material']");
                const datalist = row.querySelector("datalist");

                if (materialValue === "") {
                    // Wywołaj updateMaterials z zeruj = false, żeby odświeżyć datalistę (i nie nadpisywać już pustego inputu)
                    // jeśli chcesz aby usunięcie pola ustawiało domyślnie "Dąb" dla Stolarza, możesz użyć true zamiast false
                    updateMaterials(producentSelect, false);

                    // Jeżeli datalistka ma elementy - ustaw focus, żeby dropdown mógł być od razu otwarty przez użytkownika (na niektórych przeglądarkach)
                    if (datalist && datalist.children.length > 0) {
                        // na niektórych przeglądarkach trzeba dać lekkie opóźnienie, żeby focus zadziałał
                        setTimeout(() => {
                            materialInput.focus();
                            // Próba otwarcia natywnego dropdown (nie zawsze działa w każdej przeglądarce)
                            try { materialInput.dispatchEvent(new Event('input', { bubbles: true })); } catch (e) {}
                        }, 0);
                    }
                } else {
                    // 3) Jeśli użytkownik wpisuje tekst — filtruj datalistę jak wcześniej
                    if (datalist) {
                        filterMaterials(materialInput, datalist.id);
                    }
                }
            }
        });


        function updateMaterials(selectElement, zeruj = true) {
            const row = selectElement.closest("tr");
            const producent = selectElement.value;
            const materialInput = row.querySelector("input[name^='material']");
            const materialList = row.querySelector("datalist");
            const datalistId = materialList.id; // Unikalne ID dla tego wiersza

            if(zeruj) {
                materialInput.value = ""; // Reset materiału na pusty tekst
            }
            materialList.innerHTML = ""; // Wyczyść listę materiałów

            if (producent === "Stolarz") {
                // Dąb dla Stolarza
                const option = document.createElement("option");
                option.value = "Dąb";
                option.textContent = "Dąb";
                materialList.appendChild(option);
                materialInput.value = "Dąb"; // Ustawienie domyślnego materiału na Dąb
                materialInput.readOnly = true; // Zablokuj pole w przypadku Stolarza
            } else {
                materialInput.readOnly = false;
                if (producent in materials) {
                    materials[producent].forEach(function (material) {
                        const option = document.createElement("option");
                        option.value = material;
                        option.textContent = material;
                        materialList.appendChild(option);
                    });
                }
            }

            const typeSelect = row.querySelector("select[name^='typ']");
            typeSelect.innerHTML = "";
            ["Blat", "Parapet"].forEach(function (type) {
                const option = document.createElement("option");
                option.value = type;
                option.textContent = type;
                typeSelect.appendChild(option);
            });

            updateThickness(row);
        }

        function filterMaterials(inputElement, datalistId) {
            const filterValue = inputElement.value.toLowerCase();
            const datalist = document.getElementById(datalistId); // Znajdź datalist według unikalnego ID
            const options = datalist.querySelectorAll("option");
            options.forEach(option => {
                const optionText = option.value.toLowerCase();
                option.style.display = optionText.includes(filterValue) ? "block" : "none";
            });
        }

        document.getElementById("addRow").addEventListener("click", function () {
            try {
                console.log('addRow clicked');
                const tbody = document.getElementById("productTable");
                if (!tbody) { console.error('productTable not found'); return; }

                const rows = tbody.querySelectorAll('tr');
                const rowCount = rows.length;
                const newRow = document.createElement('tr');

                // Use incrementing id to ensure uniqueness even after deletions
                const datalistId = nextRowId++;
                newRow.dataset.rowId = datalistId; // Przypisz unikalny identyfikator

                // For copying values, use last row if present
                const lastRow = rows[rowCount - 1];

                newRow.innerHTML = `
                    <td>
                        <select name="producent_${datalistId}" required onchange="updateMaterials(this)">
                            <option value="Forma system">Forma system</option>
                            <option value="Imperial">Imperial</option>
                            <option value="Olgran">Olgran</option>
                            <option value="O rety parapety">O rety parapety</option>
                            <option value="Stolarz">Stolarz</option>
                        </select>
                    </td>
                    <td>
                        <input type="text" name="material_${datalistId}" list="materialsList_${datalistId}" oninput="filterMaterials(this, 'materialsList_${datalistId}')" required>
                        <datalist id="materialsList_${datalistId}"></datalist>
                    </td>
                    <td><select name="typ_${datalistId}" required></select></td>
                    <td><input type="text" name="dlugosc_${datalistId}" value="0" required></td>
                    <td><input type="text" name="szerokosc_${datalistId}" value="0" required></td>
                    <td>
                        <select name="grubosc_${datalistId}" required>
                        </select>
                    </td>
                    <td><input type="number" name="rabat_${datalistId}" value="0" min="0" max="100"></td>
                    <td><button type="button" class="addObrobka" data-row-id="${datalistId}">Dodaj obróbkę</button></td>
                    <input type="hidden" name="obrobki_${datalistId}" value="">
                    <td><input type="number" name="ilosc_${datalistId}" value="1" required></td>
                    <td><button type="button" class="removeRow">Usuń</button></td>
                `;


                // Copy values from last row if exists, but DO NOT copy obrobki (obróbka)
                if (rowCount > 0) {
                    const lastRow = tbody.querySelectorAll('tr')[rowCount - 1];

                    // Przepisanie wartości dla "producent"
                    const prevProducent = lastRow.querySelector("select[name^='producent']");
                    const newProducent = newRow.querySelector("select[name^='producent']");
                    if (prevProducent && newProducent) newProducent.value = prevProducent.value;

                    // Przepisanie wartości dla "material"
                    const prevMaterial = lastRow.querySelector(`input[name^='material']`);
                    const newMaterial = newRow.querySelector(`input[name^='material']`);
                    if (prevMaterial && newMaterial) newMaterial.value = prevMaterial.value;

                    // Przepisanie wartości dla "rabat"
                    const prevRabat = lastRow.querySelector("input[name^='rabat']");
                    const newRabat = newRow.querySelector("input[name^='rabat']");
                    if (prevRabat && newRabat) newRabat.value = prevRabat.value;

                    // Przepisanie typu (populujemy najpierw opcje)
                    const prevTyp = lastRow.querySelector("select[name^='typ']");
                    const newTyp = newRow.querySelector("select[name^='typ']");
                    // Upewnij się, że opcje dla typu istnieją
                    updateMaterials(newProducent, false);
                    if (prevTyp && newTyp) newTyp.value = prevTyp.value;

                    // Przepisanie grubości
                    const prevGrubosc = lastRow.querySelector("select[name^='grubosc']");
                    const newGrubosc = newRow.querySelector("select[name^='grubosc']");
                    updateThickness(newRow);
                    if (prevGrubosc && newGrubosc) newGrubosc.value = prevGrubosc.value;

                    // Przepisanie ilości
                    const prevIlosc = lastRow.querySelector("input[name^='ilosc']");
                    const newIlosc = newRow.querySelector("input[name^='ilosc']");
                    if (prevIlosc && newIlosc) newIlosc.value = prevIlosc.value;

                    // NIE kopiujemy obróbek (obrobki) - pole hidden zostaje puste
                    const newObrobki = newRow.querySelector("input[name^='obrobki_']");
                    if (newObrobki) newObrobki.value = "";

                } else {
                    // Default initial values
                    const newProducent = newRow.querySelector("select[name^='producent']");
                    if (newProducent) newProducent.value = "Forma system";

                    const newMaterial = newRow.querySelector(`input[name^='material']`);
                    if (newMaterial) newMaterial.value = "";

                    updateMaterials(newProducent, false); // Najpierw generujemy opcje dla "typ"
                }

                // Append row and update thickness/visibility
                tbody.appendChild(newRow);
                updateThickness(newRow);
                updateProductTableVisibility();
                console.log('row added, total rows:', tbody.querySelectorAll('tr').length);

            } catch (err) {
                console.error('Error adding row:', err);
            }
        });

        document.addEventListener("click", function(event) {
            if (event.target.classList.contains("removeRow")) {
                event.target.closest("tr").remove();
                // Update visibility after removal
                updateProductTableVisibility();
            }
        });

        window.onload = function () {
            document.querySelectorAll("#productTable tr").forEach(row => updateThickness(row));
            // Initial visibility sync
            updateProductTableVisibility();
            updateCustomObrobkiVisibility();

            // Delegated listener: react to inline 'Usuń' button clicks inside customObrobki table
            const customTbody = document.querySelector('#customObrobkiTable tbody');
            if (customTbody) {
                customTbody.addEventListener('click', function(e) {
                    if (e.target && e.target.tagName === 'BUTTON') {
                        // Inline onclick will remove the row first; schedule visibility update
                        setTimeout(updateCustomObrobkiVisibility, 0);
                    }
                });
            }
        };


        const obrobkiMap = {{ obrobki_data | tojson | safe }};
        let currentObrobkaRowId; // Przechowuje ID aktualnie edytowanego wiersza

        document.addEventListener("click", function(event) {
            if (event.target.classList.contains("addObrobka")) {
                currentObrobkaRowId = event.target.dataset.rowId;
                openObrobkaModal(currentObrobkaRowId);
            }
        });

        const jednostkiObrobek = {};

        for (const [producent, obrobki] of Object.entries(obrobkiMap)) {
            for (const [nazwa, dane] of Object.entries(obrobki)) {
                jednostkiObrobek[nazwa] = dane.jednostka;
            }
        }

        function openObrobkaModal(rowId) {
            document.getElementById("modalBackdrop").classList.add('show');
            document.getElementById("obrobkaModal").classList.add('show');

            const row = document.querySelector(`tr[data-row-id='${rowId}']`);
            let producent = row.querySelector("select[name^='producent']").value.toLowerCase().replace(/\s+/g, '');
            let typ = row.querySelector("select[name^='typ']").value.toLowerCase();
            let material = row.querySelector("input[name^='material']").value;

            const obrobkaList = document.getElementById("obrobkaList");
            obrobkaList.innerHTML = "";

            const hiddenInput = row.querySelector("input[name^='obrobki_']");
            const selectedMap = {};
            if (hiddenInput && hiddenInput.value) {
                hiddenInput.value
                    .split(", ")
                    .forEach(item => {
                        const [name, count] = item.split(":");
                        selectedMap[name.trim().toLowerCase()] = count ? parseInt(count, 10) : null;
                    });
            }
            console.log("selected obrobki map:", selectedMap);

            const createCategorySection = (title, obrobki) => {
                const categoryTitle = document.createElement("h4");
                categoryTitle.textContent = title;
                obrobkaList.appendChild(categoryTitle);

                obrobki.forEach(obrobka => {
                    if (!(obrobka in obrobkiMap[producent])) return;

                    const div = document.createElement("div");
                    div.classList.add("obrobka-row");

                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.value = obrobka;
                    checkbox.id = `obrobka_${obrobka}`;
                    if (selectedMap.hasOwnProperty(obrobka.toLowerCase())) checkbox.checked = true;

                    const label = document.createElement("label");
                    label.htmlFor = checkbox.id;
                    label.textContent = obrobka;
                    label.style.marginLeft = "5px";
                    label.style.flex = "1";

                    const ilosc = parseFloat(row.querySelector("input[name^='ilosc']").value) || 1;
                    const dlugosc = parseFloat(row.querySelector("input[name^='dlugosc']").value) || 0;
                    const szerokosc = parseFloat(row.querySelector("input[name^='szerokosc']").value) || 0;
                    const grubosc = parseFloat(row.querySelector("select[name^='grubosc']").value) || 0;


                    const jednostka = jednostkiObrobek[obrobka];
                    let countForCalc = ilosc;
                    if (jednostka === "ilosc" && selectedMap[obrobka.toLowerCase()] != null) {
                    countForCalc = selectedMap[obrobka.toLowerCase()];
                    }
                    const cena = policzCeneObrobki(obrobka, producent, countForCalc, dlugosc, szerokosc, grubosc);


                    const examplePrice = document.createElement("span");
                    examplePrice.style.fontSize = "0.9em";
                    examplePrice.style.color = "gray";
                    examplePrice.style.marginLeft = "10px";
                    examplePrice.textContent = cena !== null ? `~ ${cena} zł` : "brak danych";

                    div.appendChild(checkbox);
                    div.appendChild(label);

                    if (producent == "formasystem") {
                        // Dodaj obrazek, jeśli istnieje
                        const image = document.createElement("img");
                        image.src = `/static/images/${obrobka.toLowerCase()}.jpg`;
                        console.log(image.src)
                        image.alt = `Obróbka ${obrobka}`;
                        image.style.maxWidth = "150px";
                        image.style.marginLeft = "10px";
                        image.onerror = () => image.classList.add("hidden"); // ukryj, jeśli obrazek nie istnieje
                        div.appendChild(image)
                    }

                    // DODAJ INPUT NA ILOŚĆ TYLKO JEŚLI jednostka to "ilosc"
                    if (jednostka === "ilosc") {
                        const quantity = document.createElement("input");
                        quantity.type = "number";
                        quantity.min = 1;
                        quantity.value = selectedMap[obrobka.toLowerCase()] || 1;
                        quantity.style.width = "40px";
                        quantity.style.marginLeft = "10px";


                        quantity.addEventListener("input", () => {
                            const aktualnaIlosc = parseFloat(quantity.value) || 1;
                            const nowaCena = policzCeneObrobki(obrobka, producent, aktualnaIlosc, dlugosc, szerokosc);
                            examplePrice.textContent = nowaCena !== null ? `~ ${nowaCena} zł` : "brak danych";
                        });

                        div.appendChild(quantity);
                    }

                    div.appendChild(examplePrice);

                    obrobkaList.appendChild(div);
                });
            };

            if (obrobkiMap[producent]) {
                const allObrobki = obrobkiMap[producent];

                if (producent === "stolarz") {
                    const allObrobki = obrobkiMap["stolarz"];

                    const obrobkaPodstawowa = ["Otwór", "Lakier", "Kształt koła", "Frez pod okno", "Nieregularne kształty", "Podklejka", "Frez na led", "Bateria", "Barwienie Parapet", "Barwienie Blat"];
                    const blatyLazienkowe = ["Odpływ", "Umywalka nablatowa", "Umywalka podwieszana"];

                    const jednostkiObrobek = {};

                    // Ustaw jednostki
                    for (const nazwa of [...obrobkaPodstawowa, ...blatyLazienkowe]) {
                        if (allObrobki[nazwa]) {
                            jednostkiObrobek[nazwa] = allObrobki[nazwa].jednostka;
                        }
                    }

                    createCategorySection("Obróbka podstawowa", obrobkaPodstawowa);
                    createCategorySection("Blaty łazienkowe - obróbka", blatyLazienkowe);
                } else if (producent === "oretyparapety") {
                    const allObrobki = obrobkiMap["oretyparapety"];

                    const obrobkaPodstawowa = [
                        "Cięcie po skosie",
                        "Otwór nablatowy",
                        "Otwór bateria",
                        "Otwór syfon",
                        "Wycięcie narożnika",
                        "Wycięcie narożnika (poler)",
                        "Podpoler"
                    ];

                    const blatyLazienkowe = [
                        "Odpływ",
                        "Umywalka nablatowa"
                    ];

                    const jednostkiObrobek = {};

                    for (const nazwa of [...obrobkaPodstawowa, ...blatyLazienkowe]) {
                        if (allObrobki[nazwa]) {
                            jednostkiObrobek[nazwa] = allObrobki[nazwa].jednostka;
                        }
                    }

                    createCategorySection("Obróbka podstawowa", obrobkaPodstawowa);
                    createCategorySection("Blaty łazienkowe - obróbka", blatyLazienkowe);
                } else if (producent == "formasystem") {
                    let kategoria = null;

                    if (forma_technistone.includes(material)) {
                        kategoria = "1";
                    } else if (forma_dekton.includes(material)) {
                        kategoria = "2";
                    }

                    let zlewozmywak = [], profile_krawedzi = [], rodzaje_podklejek_blatow = [],
                        cokoliki = [], otwory = [], rowki_ociekaczy = [], rodzaje_wyciec = [],
                        zlewozmywaki2 = [], profile_krawedzi2 = [], rodzaje_podklejek_blatow2 = [],
                        ociekacz_szlif_cokolik = [], otwory2 = [], rodzaje_wyciec2 = [], inne = [], blaty_lazienkowe2 = [];

                    if (kategoria === "1") {
                        zlewozmywak = ["ZLEWOZMYWAK KLEJONY Z KONGLOMERATU KWARCOWEGO", "ZLEWOZMYWAK KLEJONY Z KONGLOMERATU KWARCOWEGO + KOREK AUTOMATYCZNY"];
                        profile_krawedzi = ["Krawędzie fazowane", "Ćwierćwałek", "Połwałek", "Szeroka faza góra i dół", "Krawędzie zaokrągloine, góra i dół", "Krawędzie ścięcie od dołu", "Krawędzie ścięcie od góry", "Krawędź ozdobna", "DODATKOWY POLER lub SZLIF POWIERZCHNI"];
                        rodzaje_podklejek_blatow = ["Klejenie kanapka", "Klejenie kanapka z fazą", "Podklejka 45 stopni", "Podklejka 45 stopni + zawinięcie 45 stopni", "Podklejka 45 stopni + zawinięcie", "Podklejka 45 stopni + podklejenie pianką"];
                        cokoliki = ["Cokolik do 10 cm wysokości", "Cokolik od 10 do 15 cm wysokości"];
                        otwory = ["Zlew nablatowy", "Płya grzewcza", "Umywalka nablatowa", "Zlew licowany", "Licowanie płyty", "Zlew podwieszany", "Umywalka podwieszana", "Zlew podwieszany i licowany od spodu", "Zlew podklejony z ukrytą krawędzią łączenia", "Wzmocnienia", "Bateria", "Korek", "Dozownik", "Filtr do wody", "Otwór mały do fi 3,5 cm", "Power-port", "Gniazdo elektryczne", "Odpływ umywalki"];
                        rowki_ociekaczy = ["Rowki ociekaczy", "Ociekacz", "Ociekacz z rowkami", "Frez na led", "Kapinos"];
                        rodzaje_wyciec = ["Wycięcie narożnika", "Wycięcie kształt L", "Wycięcie kształt C", "Wycięcie kształt T", "Cięcie skośne do krawędzi poziomej", "Cięcie skośne do krawędzi prostopadłej", "Cięcie skośne", "Dwa cięcia skośne", "Dwa cięcia skośne do krawędzi", "Kształt G", "Kształt trojkąt", "Zaokrąglenie krawędzi powyżej R 5cm", "Kształt półkole", "Kształt koło", "Kształt Y"];
                        Object.keys(allObrobki).filter(o =>
                        ![...zlewozmywak, ...profile_krawedzi, ...rodzaje_podklejek_blatow, ...cokoliki, ...otwory, ...rowki_ociekaczy, ...rodzaje_wyciec].includes(o)
                        );
                        createCategorySection("Otwory", otwory);
                        createCategorySection("Rodzaje wycięć", rodzaje_wyciec);
                        createCategorySection("Rodzaje podklejek blatów na długości", rodzaje_podklejek_blatow);
                        createCategorySection("Cokoliki", cokoliki);
                        createCategorySection("Rowki ociekaczy i ociekacze", rowki_ociekaczy);
                        createCategorySection("Profile krawędzi", profile_krawedzi);
                        createCategorySection("Zlewozmywak", zlewozmywak);
                        if (inne.length) createCategorySection("Inne", inne);


                    } else if (kategoria === "2") {
                        zlewozmywaki2 = ["FORMA-INTEGRA CERAMIKA KOPERTA", "FORMA-INTEGRA CERAMIKA LINIOWY"];
                        profile_krawedzi2 = ["Krawędzie fazowane SPIEK", "Szeroka faza", "Krawędzie ścięcie od dołu SPIEK", "Szeroka faza góra i dół SPIEK"];
                        rodzaje_podklejek_blatow2 = ["Podklejka 45 stopni SPIEK", "Podklejka 45 stopni + zawinięcie 45 stopni SPIEK"];
                        ociekacz_szlif_cokolik = ["Ociekacz SPIEK", "Dodatkowy szlif powierzchni", "Cokolik do 10 cm wysokości SPIEK"];
                        otwory2 = ["Zlew nablatowy SPIEK", "Płya grzewcza SPIEK", "Umywalka nablatowa SPIEK", "Zlew licowany SPIEK", "Licowanie płyty SPIEK", "Zlew podwieszany SPIEK", "Umywalka podwieszana SPIEK", "Bateria SPIEK", "Korek SPIEK", "Dozownik SPIEK", "Filtr do wody SPIEK", "Otwór mały do fi 3,5 cm SPIEK", "Power-port SPIEK", "Gniazdo elektryczne SPIEK", "Odpływ umywalki SPIEK", "Frez na led SPIEK", "Kapinos SPIEK"];
                        rodzaje_wyciec2 = ["Wycięcie narożnika SPIEK", "Wycięcie kształt L SPIEK", "Wycięcie kształt C SPIEK", "Wycięcie kształt T SPIEK", "Cięcie skośne do krawędzi poziomej SPIEK", "Cięcie skośne do krawędzi prostopadłej SPIEK", "Cięcie skośne SPIEK", "Dwa cięcia skośne SPIEK", "Dwa cięcia skośne do krawędzi SPIEK", "Kształt G SPIEK", "Kształt trojkąt SPIEK", "Zaokrąglenie krawędzi powyżej R 5cm SPIEK", "Kształt półkole SPIEK", "Kształt koło SPIEK", "Kształt Y SPIEK"];
                        Object.keys(allObrobki).filter(o =>
                        ![...zlewozmywaki2, ...profile_krawedzi2, ...rodzaje_podklejek_blatow2, ...ociekacz_szlif_cokolik, ...otwory2, ...rodzaje_wyciec2].includes(o)
                        );
                        createCategorySection("Otwory", otwory2);
                        createCategorySection("Rodzaje wycięć", rodzaje_wyciec2);
                        createCategorySection("Rodzaje podklejek blatów na długości", rodzaje_podklejek_blatow2);
                        createCategorySection("Ociekacz, szlif, cokolik", ociekacz_szlif_cokolik);
                        createCategorySection("Profile krawędzi", profile_krawedzi2);
                        createCategorySection("Zlewozmywaki", zlewozmywaki2);


                        if (inne.length) createCategorySection("Inne", inne);

                    } else {
                        createCategorySection("Inne", Object.keys(allObrobki));
                        console.log("Nie sa w kategorii")
                        alert("Wybrany materiał nie należy do znanych kategorii. Obróbki mogą być niekompletne.");
                    }

                } else if (producent == "formasystem"){
                    createCategorySection("", Object.keys(allObrobki));

                } else if (producent === "olgran" || producent === "imperial") {
                    const otwory = ["Zlew podwieszany", "Zlew nablatowy", "Bateria", "Płyta grzewcza", "Power-port", "Gniazdo elektryczne", "Licowanie płyty", "Wzmocnienie otworu", "Zlew licowany"];
                    const dodatkiBlaty = ["Ociekacz","Paski na ociekaczu", "Paski na ociekaczu - komplet", "Podklejka z cięciem", "Cięcie 45 ST", "Kaliblator LED", "Impregnacja", "Cieniowanie materiału", "Podpoler do 10 cm", "Podpoler ponad 10 cm", "Szczotkowanie"];
                    const parapetyBlaty = ["Kapinos", "Zaokrąglenie do R3", "Zaokrąglenie do R10", "Zaokrąglenie do R25", "Zaokrąglenie do R50", "Półwałek", "Ćwierćwałek", "Ćwierćwałek blatowy", "Ćwierćwałek profilowany", "Faza okrągła", "Obróbka prosta", "Cięcie po łuku", "Waterjet cięcie", "Fazowanie płytek"];
                    const blatylazienkowe = ["Odpływ", "Umywalka nablatowa", "Umywalka podwieszana"];
                    const inne = Object.keys(allObrobki).filter(o => ![...otwory, ...dodatkiBlaty, ...parapetyBlaty, ...blatylazienkowe].includes(o));

                    createCategorySection("Otwory", otwory);
                    createCategorySection("Dodatki - blaty", dodatkiBlaty);
                    createCategorySection("Parapety / blaty obróbka", parapetyBlaty);
                    createCategorySection("Blaty łazienkowe - obróbka", blatylazienkowe);
                    if (inne.length) {
                        createCategorySection("Inne", inne);
                    } else {
                        Object.keys(allObrobki).forEach(obrobka => {
                        const div = document.createElement("div");
                        div.classList.add('obrobka-row');
                        div.style.alignItems = "center";
                        div.style.marginBottom = "5px";

                        const checkbox = document.createElement("input");
                        checkbox.type = "checkbox";
                        checkbox.value = obrobka;
                        checkbox.id = `obrobka_${obrobka}`;
                        if (selectedObrobki.includes(obrobka)) checkbox.checked = true;

                        const label = document.createElement("label");
                        label.htmlFor = checkbox.id;
                        label.textContent = obrobka;
                        label.style.marginLeft = "5px";
                        label.style.flex = "1";

                        const jednostka = jednostkiObrobek[obrobka];
                        let cena = policzCeneObrobki(obrobka, producent, ilosc, dlugosc, szerokosc);

                        const examplePrice = document.createElement("span");
                        examplePrice.style.fontSize = "0.9em";
                        examplePrice.style.color = "gray";
                        examplePrice.style.marginLeft = "10px";
                        examplePrice.textContent = cena !== null ? `~ ${cena} zł` : "brak danych";

                        div.appendChild(checkbox);
                        div.appendChild(label);

                        if (jednostka === "ilosc") {
                            const quantity = document.createElement("input");
                            quantity.type = "number";
                            quantity.min = 1;
                            quantity.value = selectedMap[obrobka.toLowerCase()] || 1;
                            quantity.style.width = "40px";
                            quantity.style.marginLeft = "10px";

                            quantity.addEventListener("input", () => {
                                const aktualnaIlosc = parseFloat(quantity.value) || 1;
                                const nowaCena = policzCeneObrobki(obrobka, producent, aktualnaIlosc, dlugosc, szerokosc);
                                examplePrice.textContent = nowaCena !== null ? `~ ${nowaCena} zł` : "brak danych";
                            });

                            div.appendChild(quantity);
                        }

                        div.appendChild(examplePrice);

                        obrobkaList.appendChild(div);
                    });
                }
                }
            }

            function obliczCeneStolarz(dlugosc, szerokosc, grubosc) {
                const tabelka_stolarz = [
                    [200, 250, 360, 420],
                    [280, 400, 480, 550],
                    [380, 480, 540, 700],
                    [480, 550, 680, 730],
                    [550, 670, 770, 860],
                    [710, 770, 860, 970],
                    [830, 950, 990, 1070],
                    [900, 1030, 1160, 1230],
                    [990, 1150, 1240, 1430]
                ];

                const mb = dlugosc / 100;
                const kolumna = Math.round(grubosc) - 3;
                const wiersz = Math.ceil(szerokosc / 10) - 2;

                if (wiersz < 0 || kolumna < 0 || wiersz >= tabelka_stolarz.length || kolumna >= tabelka_stolarz[0].length) return 0;

                return tabelka_stolarz[wiersz][kolumna] * mb;
            }

            function policzCeneObrobki(obrobka, producent, ilosc, dlugosc, szerokosc, grubosc, cenaProduktu = null) {
                const dane = obrobkiMap?.[producent]?.[obrobka];
                if (!dane) return null;

                const mb = dlugosc / 100;
                const m2 = (dlugosc / 100) * (szerokosc / 100);
                const jednostka = dane.jednostka;
                const cena = dane.cena;

                if ((producent === "stolarz") && ["lakier", "nieregularne kształty"].includes(obrobka.toLowerCase())) {
                    const cenaMaterialu = obliczCeneStolarz(dlugosc, szerokosc, grubosc);
                    return Math.round(0.3 * cenaMaterialu);

                }

                switch (jednostka) {
                    case "ilosc": return Math.round(cena * ilosc);
                    case "mb": return Math.round(cena * mb);
                    case "m2": return Math.round(cena * m2);
                    default: return null;
                }


            }

            document.getElementById("modalBackdrop").classList.add('show');
            document.getElementById("obrobkaModal").classList.add('show');
        }

        // Obsługa przycisku zapisu obróbek
        document.getElementById("zapiszObrobki").addEventListener("click", function () {
            const selectedObrobki = [];


            // Przechodzimy po wszystkich checkboxach w modalu
            document.querySelectorAll("#obrobkaList input[type='checkbox']").forEach(checkbox => {
                if (!checkbox.checked) return;
                const obrobka = checkbox.value;
                const jednostka = jednostkiObrobek[obrobka] || null;
                console.log(obrobka);
                console.log(jednostka);

                let finalValue = obrobka;

                if (jednostka === "ilosc") {
                    // Spróbuj znaleźć input typu number w tym samym rodzicu co checkbox
                    const parentDiv = checkbox.closest("div");
                    const inputIlosc = parentDiv.querySelector("input[type='number']");
                    const ilosc = inputIlosc ? parseInt(inputIlosc.value) || 1 : 1;
                    finalValue = `${obrobka}:${ilosc}`;
                }

                selectedObrobki.push(finalValue);
            });

            if (currentObrobkaRowId) {
                const row = document.querySelector(`tr[data-row-id='${currentObrobkaRowId}']`);
                let hiddenInput = row.querySelector("input[name^='obrobki_']");

                if (!hiddenInput) {
                    hiddenInput = document.createElement("input");
                    hiddenInput.type = "hidden";
                    hiddenInput.name = `obrobki_${currentObrobkaRowId}`;
                    row.appendChild(hiddenInput);
                }

                hiddenInput.value = selectedObrobki.join(", ");
                console.log(hiddenInput.value);
            }
            console.log("Zapisano obróbki:", selectedObrobki);
            document.getElementById("obrobkaModal").classList.remove('show');
            document.getElementById("modalBackdrop").classList.remove('show');
        });


        // Obsługa przycisku anulowania
        document.getElementById("closeObrobkaModal").addEventListener("click", function () {
            document.getElementById("obrobkaModal").classList.remove('show');
            document.getElementById("modalBackdrop").classList.remove('show');
        });

        function pokazTabeleObrobek() {
            const tabela = document.getElementById("customObrobkiTable");
            const naglowek = document.getElementById("customObrobkiHeader");

            tabela.classList.remove('hidden');
            naglowek.classList.remove('hidden');
            dodajWierszCustomObrobki();
        }


    </script>

    <br>
    <div class="form-actions form-actions--secondary">
      <button onclick="window.location.href='/'" class="btn btn--large btn-ghost">Strona główna</button>
    </div>

    <div id="modalBackdrop" class="modal-overlay"></div>
</body>
</html>